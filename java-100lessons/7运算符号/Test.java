/**
    算数运算符
        + - * / % ++ --
        int x = 5;
        x/2 = 2;
        x%2 = 1;

    赋值运算符
        = += -= /= %=
        int x = 1;
        x += 10;

    关系运算符
        >  >=  < <=  == !=  (对象instanceof类)
    逻辑运算
        &与  ｜或  ^异或  !非  &&短路与  ||短路或 
        ^ 前后两结果不一致 返回true 否则false
        && 与 & 的区别是，&&第一个值为false后就不再走后边的运算；第一个值为true，只会看最后一个值。
        || 与 | 的区别是，||第一个值为true后不再走后边的运算；第一个值为false，只会看最后一个值。
    位bit运算
        &按位与  |按位或  ^按位异或  ~按位取反  <<按位左位移  >>按位右位移  >>>按位右位移(无符号 32byte第一位正负)
            3 & 5 = ?
            1：将 3 和 5转换成二进制表现形式
            2：竖着找对应的位置进行 & | ^ 进行计算
            3：将计算后的二进制转换成十进制

            ~5 = ?
            原码 32位byte位的二进制    0 0000000  00000000  00000000 00000110
            反码 符号不动其余 取反   0 1111111  11111111  11111111  11111001
            补码 反码基础加一   0 1111111 11111111 11111111 111111010
            计算机中不管是整数还是负数 存储的形式都是以反码的形式去存储
            注意 反码是一种表现形式 取反是一种计算过程（每一位置都取反）

            6 >> 1  ?  表示6的二进制整体往右移一位


 */

public class Test {
    public static void main(String[] args) {
        // 算数运算符
        // 先赋值再运算 运算中：自增在前的先自增再备份、自增在后的先备份再自增 最后将备份赋值给变量。
        int a = 1;
        // int b = a++;
        // System.out.println(b); // 1
        // int b = ++a;
        // System.out.println(b); // 2
        // a = a++;
        // System.out.println(a); // 1

        // 赋值运算符
        // 
        byte a = 1; // 1常量32bit位 赋值就相当于自动转化了
        // a+=2;//3 +=一个符号 自动转化 =自动转化
        // x = x + 2; // 编译出错 类型从int转化为byte可能有损失。 x空间是8bit、常量区2是32bit，在加法的时候 8bit1转换成32bit，在赋值类型不一致。
        x = (byte)(x + 2);

    }
}